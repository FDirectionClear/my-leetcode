//例子： s=leetcode k=3
/**
 * 这是第一道尝试不手写代码，只构思，看视频，直接总结的实验题型，所以没有我的题解，直接使用答案题解。这是为了寻找快速刷题的方法。
 * 
 * 总结：
 *  1. 滑动窗口很容易找到，这是一个定长的滑动窗口。
 *  2. 滑动窗口的收缩过程，必定会迎来新的元素的加入窗口，或者，已有元素的退出窗口，L和R指针移动的同时就要判断是否已经满足某些特性。
 *  每移动一下指针，都要找到方法统计一下状态。这样才能将时间复杂度发挥到极致。
 *  3. 尽量不要尝试在锁定窗口之后，再判断窗口中的子串是否满足条件。这通常情况下都要对窗口中的子串进行再一次的遍历，复杂度直逼O(n^2)，有点类似暴力求解发法了。
 * 要争取在改变窗口位置或大小的同时，通过计数等方法，对窗口内子串中的状态时刻进行更新和监视，意思就和2说的一样。
 */
var maxVowels = function (s, k) {
  const vowels = new Set(['a', 'e', 'i', 'o', 'u'])
  let count = 0,
      l = 0,
      r = 0
  while (r < k) {//初始化大小k的窗口
      vowels.has(s[r]) && count++
      r++
  }
  let max = count
  while (r < s.length) {//不断移动窗口
      vowels.has(s[r]) && count++
      vowels.has(s[l]) && count--
      l++
      r++
      max = Math.max(max, count)//更新最大元音数
  }
  return max
};
