// 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

// 只使用数字1到9
// 每个数字 最多使用一次
// 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

// 示例 1:

// 输入: k = 3, n = 7
// 输出: [[1,2,4]]
// 解释:
// 1 + 2 + 4 = 7
// 没有其他符合的组合了。
// 示例 2:

// 输入: k = 3, n = 9
// 输出: [[1,2,6], [1,3,5], [2,3,4]]
// 解释:
// 1 + 2 + 6 = 9
// 1 + 3 + 5 = 9
// 2 + 3 + 4 = 9
// 没有其他符合的组合了。
// 示例 3:

// 输入: k = 4, n = 1
// 输出: []
// 解释: 不存在有效的组合。
// 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。

// 提示:

// 2 <= k <= 9
// 1 <= n <= 60

// [1] [2,3,4,5,6,7,8,9]
//   [1 2] [3,4,5,6,7,8,9]å
//     [1 2 3] [4,5,6,7,8,9]
//     ...
//     [1 2 9] []
//   [1 3] [4,5,6,7,8,9]
// [2] [3,4,5,6,7,8,9]
// [3] [4,5,6,7,8,9]
// ...
// [9] []

/**
 * 突破口是：
只能通过穷举遍历来求解，但是由于k不固定，所以没法确定固定的for循环层数，所以得用递归。
推演过程是树状结构的，因而使用回溯最为合适。
 */
var combinationSum3 = function (k, n) {
  const result = [],
    path = [];
  let sum = 0;

  const backtracking = (start) => {
    // 这里推入path的情况应该在终止条件之前
    // 因为 start = 10的时候，path是[1,2,3,4,5,6,7,8,9]，如果此时n=45，如果先进入终止条件，那么这个1~9
    // 就被遗漏了。
    if (path.length === k && sum === n) {
      result.push(path.slice());
      return;
    }
    if (start > 9) {
      return;
    }
    for (let i = start; i <= 9; i++) {
      path.push(i);
      sum += i;
      backtracking(i + 1);
      path.pop();
      sum -= i;
    }
  };

  backtracking(1);

  return result;
};

console.log(combinationSum3(8, 36));
console.log(combinationSum3(9, 45));
